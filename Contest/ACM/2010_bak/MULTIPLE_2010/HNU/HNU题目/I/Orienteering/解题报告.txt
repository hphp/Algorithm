首先我们利用并查集来模拟初始的占位置操作
具体用一个并查集a[i]表示往后找第一个空的位置作为祖先
那么分情况讨论，合并左右界就可以了
第二部分我们得到了两个序列，等价于求两个序列A和B的最长公共部分（不一定连续）
对于常规做法是dp[i][j]二维的方程来维护，肯定是要超时的
由于这个序列具有一个性质，就是两个串的元素是相同的都是严格1到n，且严格每个出现m次
那么我们在扫描一个串B时，查询要以当前i结尾的位置的最大长度，且当前末尾必须匹配
（对于两个字串，我们总能够往前退，直到找到最优解中的最后位置，且在两个串中出现）
那么我们在当前的位置i其元素为b[i]，到着枚举在串A中的出现次数j（设p[A[i]][j]表示串A中第a[i]）
个元素刚好出现j次时的位置，得到区间[1,p[b[i]]-1]我们要查询这个区间的最大值k
然后把k+1插入到后面的位置中，这里可以用树状数组或者线段树处理
这样复杂度为m*n*mlog(n*m),空间为O(n*m)