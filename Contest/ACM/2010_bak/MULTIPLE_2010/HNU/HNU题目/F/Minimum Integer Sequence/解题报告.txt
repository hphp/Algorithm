此题可用KMP的思想，先对于B生成一个比较长度len(类似于KMP中的next数组)，然后将B与A进行比较，找到插入的位置，
先考虑A与B比较的过程，对于A[i]，假设对于j < i，A[i] < B[0]均成立，那么显然B不能插入A[i-1]之前的所有位置，若A[i] > B[0]，那么显然B插入A[i]之前就是答案，若A[i] = B[0]，则需要继续比较A[i+1]与B[1]，A[i+2]与B[2]……，在这种比较过程中，我们又需要考虑几种情况，
首先，我们对于B的情况进行讨论，若对于j > 0，均有B[j] < B[0]，那么直接进行比较即可，而且比较不需要回溯。
情况2,若对于j > 0，存在B[j] = B[0]，且存在k满足B[k] < B[j+k]，且对于0<=l<k均有B[l] = B[j+l]，那么与其用B[j]和A[i+j]继续比较下去，倒不如用B[0]和A[i+j]重新开始无回溯的比较。
情况3,若对于j > 0，存在B[j] > B[0]，那么与其用B[j]和A[i+j]继续比较下去，倒不如用B[0]和A[i+j]重新开始无回溯的比较。
满足情况2和情况3的最小的j，就是我们要求的比较长度len，求出这个len之后，遇到A[i] = B[0]的情况，我们只需要继续比较A[i+1]与B[1]、A[i+2]与B[2]……A[i+j]与B[j]，当j=len时，就直接让A[i+len]与B[0]比较即可，比较过程无需回溯。若遇到A[i+j] > B[j]，那么显然将B插入A[i]之前就是答案。