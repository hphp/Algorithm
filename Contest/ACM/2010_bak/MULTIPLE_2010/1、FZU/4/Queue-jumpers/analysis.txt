这题据说是buy tickets 的动态版,额,出的时候没有注意,不过不是很原题就是了(至少木有发现).
这题如果采用平衡树就挺好写的(当然,是指不包括敲那个冗长平衡树),百度了几个treap,然后就可以了.
用到的大概就有平衡树里面的查找第k大find_kth,以及某个值的rank这两个函数.当然我还用了几个map辅助,感觉比较
好写罢了...
大概就是将每个被top过的值存在两个平衡树上,一个是存值,一个存其对应值(对应值是用来算那些被top过的值的顺序的).
对应值我们可以很容易取一个比较大的值OFFSET,然后对每个top 的值,取其对应值为OFFSET,然后将OFFSET减1.而对于已经
top过的值的话即是更新.这样用对应值就可以维护那些被top过的值的顺序了.
Query x的话,我们可以先看x是否被top过,如果是的话,即可求.否则,只需要被top过的算比x大的数的个数,只需要x加上这个数即是新位置.
Rank x的话,首先看top过的数的大小是否超过x,如果是的话,直接在里面求,否则我们可以二分答案.
数据的话几乎纯随机,所以应该不强,希望大家能够水过去~~~~
这里感谢lccycc的友情验证.